<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon02.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon02.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon02.png">
  <link rel="mask-icon" href="/images/icon02.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 C语言1.1 标识符的组成 由字母、数字和下划线组成。 开头必须是字母或者下划线。 不能使用C关键字。  1.2 i++ 和 ++i 的区别 单独来说，i++ 和 ++i，都是 i&#x3D;i+1的意思。 当做运算符来说，就是 a&#x3D;i++ 或者 a&#x3D;++i 这样的形式。a&#x3D;i++，先赋值后自增，即先把i的值赋给a，再执行i&#x3D;i+1；而a&#x3D;++">
<meta property="og:type" content="article">
<meta property="og:title" content="「22考研 | 面试问答复习」">
<meta property="og:url" content="http://example.com/2022/03/16/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E9%9D%A2%E8%AF%95/22%E8%80%83%E7%A0%94%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="256&#39;s Blog">
<meta property="og:description" content="1 C语言1.1 标识符的组成 由字母、数字和下划线组成。 开头必须是字母或者下划线。 不能使用C关键字。  1.2 i++ 和 ++i 的区别 单独来说，i++ 和 ++i，都是 i&#x3D;i+1的意思。 当做运算符来说，就是 a&#x3D;i++ 或者 a&#x3D;++i 这样的形式。a&#x3D;i++，先赋值后自增，即先把i的值赋给a，再执行i&#x3D;i+1；而a&#x3D;++">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-90b02c25d3095b845614af0a9d5d8ce5_1440w.jpg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS92Mi1jMzFiNzM4ZGUwYjM2MDg4ZjY5YmU4NmQyZmUyMjUzZl9yLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="http://example.com/images/image-2022032701.png">
<meta property="article:published_time" content="2022-03-16T12:00:30.000Z">
<meta property="article:modified_time" content="2022-06-28T07:59:57.221Z">
<meta property="article:author" content="Ni256o">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-90b02c25d3095b845614af0a9d5d8ce5_1440w.jpg">

<link rel="canonical" href="http://example.com/2022/03/16/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E9%9D%A2%E8%AF%95/22%E8%80%83%E7%A0%94%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「22考研 | 面试问答复习」 | 256's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">256's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E9%9D%A2%E8%AF%95/22%E8%80%83%E7%A0%94%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar01.JPG">
      <meta itemprop="name" content="Ni256o">
      <meta itemprop="description" content="The sole certainty is that tomorrow will surprise us all.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="256's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「22考研 | 面试问答复习」
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-16 20:00:30" itemprop="dateCreated datePublished" datetime="2022-03-16T20:00:30+08:00">2022-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-28 15:59:57" itemprop="dateModified" datetime="2022-06-28T15:59:57+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考研复试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1 C语言"></a>1 C语言</h2><h3 id="1-1-标识符的组成"><a href="#1-1-标识符的组成" class="headerlink" title="1.1 标识符的组成"></a>1.1 标识符的组成</h3><ol>
<li>由字母、数字和下划线组成。</li>
<li>开头必须是字母或者下划线。</li>
<li>不能使用C关键字。</li>
</ol>
<h3 id="1-2-i-和-i-的区别"><a href="#1-2-i-和-i-的区别" class="headerlink" title="1.2 i++ 和 ++i 的区别"></a>1.2 i++ 和 ++i 的区别</h3><ol>
<li>单独来说，i++ 和 ++i，都是 i&#x3D;i+1的意思。</li>
<li>当做运算符来说，就是 a&#x3D;i++ 或者 a&#x3D;++i 这样的形式。<br>a&#x3D;i++，先赋值后自增，即先把i的值赋给a，再执行i&#x3D;i+1；<br>而a&#x3D;++i，先自增后赋值，即先执行i&#x3D;i+1，再把i的值赋给a；</li>
</ol>
<p>举个例子：<br>i&#x3D;4    如执行 a&#x3D;i++ 语句，则 a&#x3D;4，i&#x3D;5；如执行 a&#x3D;++i 语句，则 i&#x3D;5，a&#x3D;5；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">12</span>, n = <span class="number">34</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>, m++, ++n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d\n&quot;</span>, n++, ++m);</span><br><span class="line">&#125;    <span class="comment">// 程序运行后的输出结果是：12353514。</span></span><br></pre></td></tr></table></figure>

<p>同理，i– 和 –i 的用法也是一样的。</p>
<h3 id="1-3-用变量a给出下面的定义"><a href="#1-3-用变量a给出下面的定义" class="headerlink" title="1.3 用变量a给出下面的定义"></a>1.3 用变量a给出下面的定义</h3><p><strong>一个整型数(An integer)</strong> int a;</p>
<p><strong>一个指向整型数的指针(A pointer to an integer)</strong> int *a;</p>
<p><strong>一个指向指针的的指针，它指向的指针是指向一个整型数(A pointer to a pointer to an integer)</strong> int **a;</p>
<p><strong>一个有10个整型数的数组(An array of 10 integers)</strong> int a[10];</p>
<p><strong>一个有10个指针的数组，该指针是指向一个整型数的(An array of 10 pointers to integers)</strong> int *a[10];</p>
<p><strong>一个指向有10个整型数数组的指针(A pointer to an array of 10 integers)</strong> int (*a)[10];</p>
<p><strong>一个指向函数的指针，该函数有一个整型参数并返回一个整型数(A pointer to a function that takes an integer as an argument and returns an integer)</strong> int (*a)(int);</p>
<p><strong>一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</strong> int (*a[10])(int);</p>
<h3 id="1-4-指针和引用的区别"><a href="#1-4-指针和引用的区别" class="headerlink" title="1.4 指针和引用的区别"></a>1.4 指针和引用的区别</h3><ol>
<li>指针是一个存储地址的变量，该地址为内存的一个存储单元；引用是原变量的一个别名。</li>
<li>指针在定义时可以不初始化，可以在定义后的任何地方重新赋值；引用在创建时必须初始化，引用到一个有效的对象。</li>
<li>指针可以为NULL；引用不行。</li>
<li>指针可以有多级，而引用只能有一级。</li>
</ol>
<h3 id="1-5-三种传参方式？"><a href="#1-5-三种传参方式？" class="headerlink" title="1.5 三种传参方式？"></a>1.5 三种传参方式？</h3><p>值传递：传递的是实参的一个拷贝，修改形参不会改变实参值。<br>地址传递：传递的是实参地址的一个拷贝，修改形参不会改变实参值。<br>引用传递：传递的是实参的一个别名，修改形参会导致改变实参。<br>被调用函数的形参只有在被调用时才会临时分配存储单元，一旦调用结束则释放内存。</p>
<h3 id="1-6-include-尖括号和双引号区别？"><a href="#1-6-include-尖括号和双引号区别？" class="headerlink" title="1.6 #include 尖括号和双引号区别？"></a>1.6 #include 尖括号和双引号区别？</h3><p>&lt;&gt;是标准头文件，“”是非系统头文件</p>
<h3 id="1-7-程序编译成可执行程序四个的过程"><a href="#1-7-程序编译成可执行程序四个的过程" class="headerlink" title="1.7 程序编译成可执行程序四个的过程"></a>1.7 程序编译成可执行程序四个的过程</h3><p>预处理、编译、汇编和链接。</p>
<h3 id="1-8-如何避免野指针？"><a href="#1-8-如何避免野指针？" class="headerlink" title="1.8 如何避免野指针？"></a>1.8 如何避免野指针？</h3><p>声明指针记得初始化，暂时不用就指向NULL；使用malloc分配内存，必须经过显式释放(free)，避免内存泄漏。</p>
<h2 id="2-C"><a href="#2-C" class="headerlink" title="2 C++"></a>2 C++</h2><h3 id="2-1-C-的特点"><a href="#2-1-C-的特点" class="headerlink" title="2.1 C++的特点"></a>2.1 C++的特点</h3><p>C++是在C语言的基础上发展而来的。同时支持<u>面向过程</u>和<u>面向对象</u>的程序设计。（<em>C语言纯面向过程，Java纯面向对象</em>）</p>
<ul>
<li><p><strong>封装</strong> 被定义为“把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。封装只公开某些对外接口，隐藏具体实现细节。增加了一定的安全性，防止信息的泄露以及破坏。</p>
</li>
<li><p><strong>继承</strong> 在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能<strong>。</strong></p>
</li>
<li><p><strong>多态</strong> 多态指在程序设计中存在同名不同方法的存在，主要通过子类对父类的覆盖来实现多态，设计原则之一就是要依赖于抽象，而不依赖于具体，增加灵活性。多态就是为了体现这一原则。</p>
</li>
</ul>
<h3 id="2-2-C-的异常处理机制"><a href="#2-2-C-的异常处理机制" class="headerlink" title="2.2 C++的异常处理机制"></a>2.2 C++的异常处理机制</h3><p>抛出异常和捕捉异常进行处理。</p>
<h3 id="2-3-C-的纯虚函数"><a href="#2-3-C-的纯虚函数" class="headerlink" title="2.3 C++的纯虚函数"></a>2.3 C++的纯虚函数</h3><p>被virtual修饰的成员函数。纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p>
<h3 id="2-4-动态关联和静态关联的区别"><a href="#2-4-动态关联和静态关联的区别" class="headerlink" title="2.4 动态关联和静态关联的区别"></a>2.4 动态关联和静态关联的区别</h3><p>通过基类指针调用虚函数的方式是动态关联，通过对象调用虚函数的方式是静态关联。</p>
<h3 id="2-5-重载（overload）和重写（overried）的区别"><a href="#2-5-重载（overload）和重写（overried）的区别" class="headerlink" title="2.5 重载（overload）和重写（overried）的区别"></a>2.5 重载（overload）和重写（overried）的区别</h3><p>重载：是指函数名相同，而参数列表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p>
<p>重写：是指子类重新定义父类虚函数的方法。和多态真正相关。</p>
<h3 id="2-6-class和struct的区别"><a href="#2-6-class和struct的区别" class="headerlink" title="2.6 class和struct的区别"></a>2.6 class和struct的区别</h3><ol>
<li><p>class中成员默认是private，struct中成员默认是public；</p>
</li>
<li><p>在继承关系中，class默认是private，而struct默认是public；</p>
</li>
<li><p>class可用于定义模板参数，但是strcut不能。</p>
</li>
</ol>
<h3 id="2-7-构造方法（构造函数）的特点"><a href="#2-7-构造方法（构造函数）的特点" class="headerlink" title="2.7 构造方法（构造函数）的特点"></a>2.7 构造方法（构造函数）的特点</h3><ol>
<li><p>当一个对象被创建时候，构造方法用来初始化该对象。</p>
</li>
<li><p>构造方法的方法名与其所在的类名相同。 </p>
</li>
<li><p>构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。 </p>
</li>
<li><p>构造方法不能由编程人员调用，而要系统调用。 </p>
</li>
<li><p>一个类可以定义多个构造方法，如果没有定义构造方法，编译系统会自动插入一个默认的无参构造方法，这个构造方法不执行任何代码。 </p>
</li>
<li><p>构造方法可以重载，以参数的个数，类型，或排列顺序区分。</p>
</li>
</ol>
<h3 id="2-8-内联函数的一般特点"><a href="#2-8-内联函数的一般特点" class="headerlink" title="2.8 内联函数的一般特点"></a>2.8 内联函数的一般特点</h3><ol>
<li><p>不是任何一个函数都可定义成内联函数。</p>
</li>
<li><p>内联函数的函数体内不能含有复杂的结构控制语句，例如 while、switch，并且内联函数本身不能是直接递归函数（即自己内部还调用自己的函数）。</p>
</li>
<li><p>内联函数一般适合于只有1~5行语句的小函数。</p>
</li>
</ol>
<h3 id="2-9-哪些常见函数不能声明为虚函数？"><a href="#2-9-哪些常见函数不能声明为虚函数？" class="headerlink" title="2.9 哪些常见函数不能声明为虚函数？"></a>2.9 哪些常见函数不能声明为虚函数？</h3><p>普通函数(非成员函数)，静态成员函数，内联成员函数，构造函数，友元函数。</p>
<h3 id="2-10-友元函数有哪些特性？"><a href="#2-10-友元函数有哪些特性？" class="headerlink" title="2.10 友元函数有哪些特性？"></a>2.10 友元函数有哪些特性？</h3><ol>
<li>友元函数是一种在类外定义，在类内特殊声明（加关键字friend）的函数；</li>
<li>可以在类外访问类的所有成员的非成员函数；</li>
<li>友元函数相对于普通函数，增加了访问类成员的权利；</li>
<li>友元函数可以像普通函数一样直接调用，不需要通过对象或指针；</li>
<li>友元函数不是成员函数，所以不能被继承，也同样没有this指针；</li>
<li>友元函数和普通函数的区别在于是否具有访问类成员的权利；</li>
<li>友元函数在一定程度上破坏了类的封装特性。</li>
</ol>
<h3 id="2-11-对于派生类的构造函数，创建对象时构造函数执行的顺序为？"><a href="#2-11-对于派生类的构造函数，创建对象时构造函数执行的顺序为？" class="headerlink" title="2.11 对于派生类的构造函数，创建对象时构造函数执行的顺序为？"></a>2.11 对于派生类的构造函数，创建对象时构造函数执行的顺序为？</h3><ol>
<li>基类的构造函数；</li>
<li>成员对象构造函数；</li>
<li>派生类本身的构造函数。</li>
</ol>
<p>记忆方式：先父母，再客人，后自己。</p>
<h3 id="2-12-模板的使用是为了什么？"><a href="#2-12-模板的使用是为了什么？" class="headerlink" title="2.12 模板的使用是为了什么？"></a>2.12 模板的使用是为了什么？</h3><p>提高代码的可重用性。</p>
<h3 id="2-13-关键字static、const"><a href="#2-13-关键字static、const" class="headerlink" title="2.13 关键字static、const"></a>2.13 关键字static、const</h3><p>static：静态变量，只在第一次运行到这里时初始化，存到全局数据区；</p>
<p>const：表示常量，不可以修改的变量。</p>
<h3 id="2-14-const和-define的区别"><a href="#2-14-const和-define的区别" class="headerlink" title="2.14 const和#define的区别"></a>2.14 const和#define的区别</h3><ol>
<li>const是声明常量；#define是宏定义。</li>
<li>const是在编译运行时起作用，#define是在编译的预处理阶段起作用。</li>
<li>const有对应的数据类型；#define是字符替换。</li>
<li>const可以看作是一个只读变量，有作用域，需要分配内存。</li>
<li>const可以进行调试；#define不能进行调试，因为在预处理阶段就已经替换掉了。</li>
</ol>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-1-逻辑结构"><a href="#3-1-逻辑结构" class="headerlink" title="3.1 逻辑结构"></a>3.1 逻辑结构</h3><img src="https://pic2.zhimg.com/80/v2-90b02c25d3095b845614af0a9d5d8ce5_1440w.jpg" alt="逻辑结构" style="zoom:60%;" />

<h3 id="3-2-常见的数据结构"><a href="#3-2-常见的数据结构" class="headerlink" title="3.2 常见的数据结构"></a>3.2 常见的数据结构</h3><ol>
<li>数组：顺序存储，随机访问</li>
<li>链表：链式存储，顺序访问</li>
<li>栈：操作受限的线性表，只能在栈顶进行插入删除操作，遵循先进后出原则</li>
<li>队列 ：操作受限的线性表，只能在队尾进行插入操作，队头进行删除操作，遵循先进先出原则</li>
<li>树：二叉树、平衡二叉树、大根堆，小根堆等</li>
<li>图：最短路径，关键路径</li>
</ol>
<h3 id="3-3-数组和链表的区别"><a href="#3-3-数组和链表的区别" class="headerlink" title="3.3 数组和链表的区别"></a>3.3 数组和链表的区别</h3><ul>
<li>从逻辑结构来看：<ul>
<li><strong>数组</strong> 必须事先定义<u>固定的长度</u>（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标<u>直接存取</u>。</li>
<li><strong>链表</strong> <u>动态</u>地进行存储<u>分配</u>，可以适应数据动态地增减的情况，且可以<u>方便</u>地<u>插入</u>、<u>删除</u>数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐），链表必须根据next指针找到下一个元素。</li>
</ul>
</li>
<li>从内存存储来看：<ul>
<li>(静态)数组从栈中分配空间，对于程序员方便快速，但是自由度小。</li>
<li>链表从堆中分配空间，自由度大但是申请管理比较麻烦</li>
</ul>
</li>
</ul>
<p>从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反， 如果需要经常插入和删除元素就需要用链表数据结构了。</p>
<h3 id="3-4-时间复杂度"><a href="#3-4-时间复杂度" class="headerlink" title="3.4 时间复杂度"></a>3.4 时间复杂度</h3><h4 id="（1）语句的频度是指什么？"><a href="#（1）语句的频度是指什么？" class="headerlink" title="（1）语句的频度是指什么？"></a>（1）语句的频度是指什么？</h4><p>该语句在算法中被重复执行的次数。</p>
<h4 id="（2）大T是什么意思？"><a href="#（2）大T是什么意思？" class="headerlink" title="（2）大T是什么意思？"></a>（2）大T是什么意思？</h4><p>算法中所有语句的频度之和。</p>
<h4 id="（3）大O是什么意思？"><a href="#（3）大O是什么意思？" class="headerlink" title="（3）大O是什么意思？"></a>（3）大O是什么意思？</h4><p>是时间复杂度的表示，用来描述大T的数量级。</p>
<h3 id="3-5-栈的应用"><a href="#3-5-栈的应用" class="headerlink" title="3.5 栈的应用"></a>3.5 栈的应用</h3><h4 id="（1）括号匹配"><a href="#（1）括号匹配" class="headerlink" title="（1）括号匹配"></a>（1）括号匹配</h4><p>遇左括号入栈，遇右括号弹出栈顶元素，检查是否匹配。</p>
<h4 id="（2）用栈实现中缀表达式转后缀表达式"><a href="#（2）用栈实现中缀表达式转后缀表达式" class="headerlink" title="（2）用栈实现中缀表达式转后缀表达式"></a>（2）用栈实现中缀表达式转后缀表达式</h4><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。</p>
<p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<ol>
<li>遇到<strong>操作数</strong>。直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。若碰到“(”或栈空停止，再把当前运算符入栈。</li>
</ol>
<h3 id="3-6-找子串问题"><a href="#3-6-找子串问题" class="headerlink" title="3.6 找子串问题"></a>3.6 找子串问题</h3><p>在一个字符串中找是否包含目标的匹配字符串。</p>
<p>暴力求解：匹配失败，主串扫描指针i++，子串从头开始匹配。最坏时间复杂度 O(nm)。</p>
<p><strong>KMP算法</strong>：匹配失败，主串指针不回溯，移动位数 i &#x3D; 已匹配的字符数 - 对应的部分匹配值，子串 j &#x3D; 对应的部分匹配值 + 1。平均时间复杂度 O(m + n)。</p>
<p>其中，对应的部分匹配值（PM）&#x3D; 最长相等前后缀长度。</p>
<p>例：ababa</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PM</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="3-7-树"><a href="#3-7-树" class="headerlink" title="3.7 树"></a>3.7 树</h3><p>二叉树 VS 度为2的树：二叉树可以为空；度为2的树至少又有一个结点度为2。</p>
<p>平衡二叉树：左右子树的深度差不大于1。</p>
<p>哈夫曼树：带权路径长度最小。</p>
<p>前缀编码：没有一个编码是另一个编码的前缀。</p>
<h3 id="3-8-最短路径算法"><a href="#3-8-最短路径算法" class="headerlink" title="3.8 最短路径算法"></a>3.8 最短路径算法</h3><p><strong>prim算法</strong>：从一个顶点出发，找顶点集合里所有<u>相邻边里最短边</u>，如果该条边连接的顶点未加入顶点集合，就把该顶点加入顶点集合，否则找下一条最短边。</p>
<p><strong>Kruskal算法</strong>：<u>在边集合里，找最短边</u>，如果该条边连接的顶点未加入顶点集合，就把该顶点加入集合，否则找下一条最短边。</p>
<p>dijkstra算法：</p>
<p>Floyd算法：</p>
<h3 id="3-9-哈希表"><a href="#3-9-哈希表" class="headerlink" title="3.9 哈希表"></a>3.9 哈希表</h3><p>哈希表又称为散列表，是根据关键字码的值直接进行访问的数据结构。</p>
<p>构造哈希函数的方法：直接定址法，除留余数法，数字分析法，平方取中法，折叠法，随机数法等。（直接定址法，除留余数法比较重要）</p>
<p>解决冲突的方法：开放定址法和拉链法（开放定址法更重要），开放定址法包括线性探查法，二次探查法，双重散列法。</p>
<h3 id="3-10-排序算法及比较"><a href="#3-10-排序算法及比较" class="headerlink" title="3.10 排序算法及比较"></a>3.10 排序算法及比较</h3><p>插入排序：<strong>直接插入排序</strong>（将数据插入已排序好的序列里），<strong>希尔排序</strong>（缩小增量排序，相隔某增量的数据组成一个子表，子表分别进行直接插入排序）。</p>
<p>选择排序：简单选择排序（每趟从无序序列中选择最小&#x2F;大的一个数加入有序序列）、<strong>堆排序</strong>（大根堆，根&gt;左右，小的数往下坠，每次与孩子中比自己大且更大的数“换”位置）。</p>
<p>交换排序：冒泡排序、<strong>快速排序</strong>（找基准数，一个指针从前往后遍历，一个指针从后往前遍历，前指针找到比基准数大的，后指针找到比基准数小的，两个交互位置，直到前指针和后指针相遇，每躺排序都可以确定基准数的位置）。</p>
<p><strong>归并排序</strong>，<strong>基数排序</strong>（个、十、百按位排序）等。</p>
<table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏情况下时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直接插入排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">简单选择排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n²)</td>
<td align="center">O(logn)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(d(n + r))</td>
<td align="center">O(d(n + r))</td>
<td align="center">O(r)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h3 id="3-11-贪心算法和动态规划"><a href="#3-11-贪心算法和动态规划" class="headerlink" title="3.11 贪心算法和动态规划"></a>3.11 贪心算法和动态规划</h3><p>贪心算法：局部最优解</p>
<p>动态规划：全局最优解</p>
<h2 id="4-操作系统"><a href="#4-操作系统" class="headerlink" title="4 操作系统"></a>4 操作系统</h2><h3 id="4-1-操作系统的特点"><a href="#4-1-操作系统的特点" class="headerlink" title="4.1 操作系统的特点"></a>4.1 操作系统的特点</h3><p>共享、并发、虚拟、异步。</p>
<h3 id="4-2-操作系统的主要功能"><a href="#4-2-操作系统的主要功能" class="headerlink" title="4.2 操作系统的主要功能"></a>4.2 操作系统的主要功能</h3><p>操作系统是一组控制和管理计算机硬件和软件资源，合理的对各类作业进行调度，以及方便用户使用的程序的集合。它包含五种功能：进程管理、存储管理、设备管理、作业管理、文件管理。</p>
<h3 id="4-3-进程的三个组成部分？"><a href="#4-3-进程的三个组成部分？" class="headerlink" title="4.3 进程的三个组成部分？"></a>4.3 进程的三个组成部分？</h3><p>程序段、数据段、PCB(Process Control Block)</p>
<h3 id="4-4-并行和并发"><a href="#4-4-并行和并发" class="headerlink" title="4.4 并行和并发"></a>4.4 并行和并发</h3><p>  并行：指两个或多个事件在同一时刻进行。</p>
<p>  并发：指两个或多个事件在同一时间间隔内发生。</p>
<h3 id="4-5-进程和程序的区别"><a href="#4-5-进程和程序的区别" class="headerlink" title="4.5 进程和程序的区别"></a>4.5 进程和程序的区别</h3><p>进程的构成：进程控制块（PCB），程序块，数据段。</p>
<ol>
<li>进程是一个动态概念，而程序是一个静态概念，程序是指令的有序集合，无执行含义，进程则强调执行的过程。</li>
<li>进程具有并行特征（独立性，异步性），程序则没有。</li>
<li>不同的进程可以包含同一个程序，同一个程序在执行中也可以产生多个进程。</li>
</ol>
<h3 id="4-6-描述进程的三个基本状态以及它们之间转换的典型原因。"><a href="#4-6-描述进程的三个基本状态以及它们之间转换的典型原因。" class="headerlink" title="4.6 描述进程的三个基本状态以及它们之间转换的典型原因。"></a>4.6 描述进程的三个基本状态以及它们之间转换的典型原因。</h3><ol>
<li>就绪状态。即进程已分配到除CPU以外的所有必要的资源后，只要能再获得处理机，便可立即执行。</li>
<li>执行状态。指进程已获得处理机，其程序正在执行。</li>
<li>阻塞状态。指进程因发生某事件，如I&#x2F;O请求，申请缓冲空间等而暂停执行时的状态。</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS92Mi1jMzFiNzM4ZGUwYjM2MDg4ZjY5YmU4NmQyZmUyMjUzZl9yLmpwZw?x-oss-process=image/format,png" alt="进程的基本状态"> </p>
<p>转换原因：</p>
<p>就绪到执行：进程调度。</p>
<p>执行到就绪：时间片用完或抢占式调度中有更高优先级的进程进入就绪队列。</p>
<p>执行到阻塞：I&#x2F;O请求或等待事件发生。</p>
<p>阻塞到就绪：I&#x2F;O完成或事件已发生。</p>
<h3 id="4-7-在创建一个进程时，操作系统需要完成的主要工作是什么？"><a href="#4-7-在创建一个进程时，操作系统需要完成的主要工作是什么？" class="headerlink" title="4.7 在创建一个进程时，操作系统需要完成的主要工作是什么？"></a>4.7 在创建一个进程时，操作系统需要完成的主要工作是什么？</h3><ol>
<li>操作系统发现请求创建新进程后，调用进程创建原语。</li>
<li>申请空闲的PCB。</li>
<li>为新进程分配资源。</li>
<li>初始化进程控制块（PCB）。</li>
<li>把新进程插入就绪队列。</li>
</ol>
<h3 id="4-8-死锁产生的原因："><a href="#4-8-死锁产生的原因：" class="headerlink" title="4.8 死锁产生的原因："></a>4.8 死锁产生的原因：</h3><ol>
<li>系统提供的资源有限；</li>
<li>进程推进顺序不当。</li>
</ol>
<h3 id="4-9-产生死锁的必要条件"><a href="#4-9-产生死锁的必要条件" class="headerlink" title="4.9 产生死锁的必要条件"></a>4.9 产生死锁的必要条件</h3><ol>
<li>互斥条件：某段时间内某资源只能由一个进程使用。</li>
<li>不可剥夺条件：资源在未使用完前，不能被剥夺，由使用进程释放。</li>
<li>请求并保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放。</li>
<li>循环等待条件：发生死锁时，有向图必构成一环路。</li>
</ol>
<h3 id="4-10-解决死锁的方法"><a href="#4-10-解决死锁的方法" class="headerlink" title="4.10 解决死锁的方法"></a>4.10 解决死锁的方法</h3><p>条件：互斥、请求并保持、不可剥夺、循环等待。</p>
<p>解决方法： 死锁预防、死锁避免、死锁检测和解除。</p>
<h3 id="4-11-简述死锁预防与死锁避免的区别。"><a href="#4-11-简述死锁预防与死锁避免的区别。" class="headerlink" title="4.11 简述死锁预防与死锁避免的区别。"></a>4.11 简述死锁预防与死锁避免的区别。</h3><p><strong>死锁预防</strong> 是系统预先确定一些资源分配策略，进程按规定申请资源，系统按预先规定的策略进行分配，从而防止死锁的发生。</p>
<p><strong>死锁避免</strong> 是当进程提出资源申请时系统测试资源分配，仅当能确保系统安全时才把资源分配给进程，使系统一直处于安全状态之中，从而避免死锁。</p>
<h3 id="4-12-分页与分段的区别？"><a href="#4-12-分页与分段的区别？" class="headerlink" title="4.12 分页与分段的区别？"></a>4.12 分页与分段的区别？</h3><ol>
<li>页是物理单位，目的是提高内存的使用率；段是逻辑单位，目的是方便用户使用。</li>
<li>页的大小是固定的由系统决定；段的大小不固定且由用户决定。</li>
<li>分页作业的地址空间是一维的；分段作业的地址空间是二维的。</li>
<li>分页内存利用率高，产生内部碎片；分段拥有逻辑意义，有利于共享，产生外部碎片。</li>
</ol>
<h3 id="4-13-分页与分段内存管理方案如何进行逻辑地址到物理地址的转换？"><a href="#4-13-分页与分段内存管理方案如何进行逻辑地址到物理地址的转换？" class="headerlink" title="4.13 分页与分段内存管理方案如何进行逻辑地址到物理地址的转换？"></a>4.13 分页与分段内存管理方案如何进行逻辑地址到物理地址的转换？</h3><p><strong>分页</strong>：由虚地址中的页号为索引，查页表，找出该页对应的页表项的地址，根据此地址到内存读出对应的块号，最后将块号和页内偏移量拼接的到对应的物理地址。</p>
<p><strong>分段</strong>：由虚地址中的段号为索引，查段表，找出该段在内存的起始地址，并将其和段内地址相加，从而得到物理地址。</p>
<h3 id="4-14-什么是快表？它在地址转换中起什么作用？"><a href="#4-14-什么是快表？它在地址转换中起什么作用？" class="headerlink" title="4.14 什么是快表？它在地址转换中起什么作用？"></a>4.14 什么是快表？它在地址转换中起什么作用？</h3><p>快表是一个高速的、具有并行查询能力的联想存储器，用于存放正运行的进程的当前页号和块号，或者段号和段起始地址。</p>
<p>加入快表后，在地址转换时，首先在快表中查找，若找到就直接进行地址转换；未找到，则在主存页表继续查找，并把查到的页号和块号放入联想存储器中。快表的命中率很高，有效地提高了地址转换的速度。</p>
<h3 id="4-15-页面置换算法"><a href="#4-15-页面置换算法" class="headerlink" title="4.15 页面置换算法"></a>4.15 页面置换算法</h3><ul>
<li>最佳置换算法OPT 。（把未来最久不被使用的页面换出去，实际无法实现）</li>
<li>先进先出置换算法FIFO</li>
<li>最近最久未使用算法LRU</li>
<li>时钟算法CLOCK</li>
<li>改进型时钟算法</li>
</ul>
<h3 id="4-16-调度算法（进程调度-x2F-作业调度）？"><a href="#4-16-调度算法（进程调度-x2F-作业调度）？" class="headerlink" title="4.16 调度算法（进程调度&#x2F;作业调度）？"></a>4.16 调度算法（进程调度&#x2F;作业调度）？</h3><ul>
<li>先来先服务(FCFS)调度算法：非抢占式；不会饥饿</li>
<li>短作业优先(SJF&#x2F;SPF)调度算法：非抢占式；会饥饿</li>
<li>最短剩余时间优先(SRTN)调度算法：抢占式；会饥饿</li>
<li>高响应比优先(HRRN)调度算法：非抢占式；不会饥饿</li>
<li>时间片轮转(RR)调度算法：抢占式；不会饥饿</li>
<li>优先级调度算法：都有；会饥饿</li>
<li>多级反馈队列调度算法：抢占式；会饥饿</li>
</ul>
<h3 id="4-17-磁盘调度算法？"><a href="#4-17-磁盘调度算法？" class="headerlink" title="4.17 磁盘调度算法？"></a>4.17 磁盘调度算法？</h3><ul>
<li>先来先服务FCFS</li>
<li>最短寻道时间优先SSTF</li>
<li>扫描算法SCAN</li>
<li>循环扫描算法C-SCAN</li>
</ul>
<h3 id="4-18-硬中断与软中断的区别？"><a href="#4-18-硬中断与软中断的区别？" class="headerlink" title="4.18 硬中断与软中断的区别？"></a>4.18 硬中断与软中断的区别？</h3><p>硬中断：硬中断是由硬件产生的，可以直接中断CPU。</p>
<p>软中断：软中断是由当前正在运行的进程产生的，不能中断CPU，软中断是需要内核为正在运行的进程去做一些I&#x2F;O请求。</p>
<h3 id="4-19-中断和系统调用区别？"><a href="#4-19-中断和系统调用区别？" class="headerlink" title="4.19 中断和系统调用区别？"></a>4.19 中断和系统调用区别？</h3><p>中断：解决处理器速度和硬件速度不匹配，是多道程序设计的必要条件。每个中断都有自己的数字标识，当中断发生时，指令计数器PC和处理机状态字PSW中的内容自动压入处理器堆栈，同时新的PC和PSW的中断向量也装入各自的寄存器中。这时，PC中包含的是该中断的中断处理程序的入口地址，它控制程序转向相应的处理，当中断处理程序执行完毕，该程序的最后一条iret（中断返回），它控制着恢复调用程序的环境。</p>
<p>中断和系统调用的区别：中断是由外设产生，无意的，被动的</p>
<p>系统调用是由应用程序请求操作系统提供服务产生，有意的，主动的。</p>
<p>要从用户态通过中断进入内核态。（联系）</p>
<p>中断过程：中断请求 中断响应 断点保护 执行中断服务程序 断点恢复 中断返回</p>
<p>系统调用过程：应用程序在用户态执行时请求系统调用，中断，从用户态进入内核态，在内核态执行相应的内核代码。</p>
<h2 id="5-计算机网络"><a href="#5-计算机网络" class="headerlink" title="5 计算机网络"></a>5 计算机网络</h2><h3 id="5-1-Internet采用哪种网络协议？该协议的主要层次结构？"><a href="#5-1-Internet采用哪种网络协议？该协议的主要层次结构？" class="headerlink" title="5.1 Internet采用哪种网络协议？该协议的主要层次结构？"></a>5.1 Internet采用哪种网络协议？该协议的主要层次结构？</h3><p>TCP&#x2F;IP协议</p>
<p>主要层次结构为： 网络接口层、网络层、传输层、应用层。</p>
<h3 id="5-2-Internet物理地址和IP地址转换采用什么协议？"><a href="#5-2-Internet物理地址和IP地址转换采用什么协议？" class="headerlink" title="5.2 Internet物理地址和IP地址转换采用什么协议？"></a>5.2 Internet物理地址和IP地址转换采用什么协议？</h3><p>ARP (Address Resolution Protocol)（地址解析协议）</p>
<h3 id="5-3-IP地址的编码分为哪俩部分？"><a href="#5-3-IP地址的编码分为哪俩部分？" class="headerlink" title="5.3 IP地址的编码分为哪俩部分？"></a>5.3 IP地址的编码分为哪俩部分？</h3><p>IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。</p>
<h3 id="5-4-OSI，TCP-x2F-IP，五层协议的体系结构"><a href="#5-4-OSI，TCP-x2F-IP，五层协议的体系结构" class="headerlink" title="5.4 OSI，TCP&#x2F;IP，五层协议的体系结构"></a>5.4 OSI，TCP&#x2F;IP，五层协议的体系结构</h3><p>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>TCP&#x2F;IP分层（4层）：网络接口层、网络层、传输层、应用层。</p>
<p>五层协议（5层）：物理层、数据链路层、网络层、传输层、应用层。</p>
<p>每一层的作用如下：</p>
<ul>
<li>物理层：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。</li>
<li>数据链路层：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</li>
<li>网络层：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。</li>
<li>传输层：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</li>
<li>会话层：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</li>
<li>表示层：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</li>
<li>应用层：为操作系统或网络应用程序提供访问网络服务的接口。</li>
</ul>
<h3 id="5-5-IP地址的分类"><a href="#5-5-IP地址的分类" class="headerlink" title="5.5 IP地址的分类"></a>5.5 IP地址的分类</h3><ul>
<li>A类地址：以0开头，第一个字节范围：0~127；</li>
<li>B类地址：以10开头，第一个字节范围：128~191；</li>
<li>C类地址：以110开头，第一个字节范围：192~223；</li>
<li>D类地址：以1110开头，第一个字节范围为224~239；</li>
</ul>
<h3 id="5-6-IP组播有那些好处"><a href="#5-6-IP组播有那些好处" class="headerlink" title="5.6 IP组播有那些好处?"></a>5.6 IP组播有那些好处?</h3><p>Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播技术的核心就是针对如何节约网络资源的前提下保证服务质量。</p>
<h3 id="5-7-ARP协议的工作原理"><a href="#5-7-ARP协议的工作原理" class="headerlink" title="5.7 ARP协议的工作原理"></a>5.7 ARP协议的工作原理</h3><p>首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。</p>
<p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：</p>
<ul>
<li><p>如果有，就直接将数据包发送到这个MAC地址；</p>
</li>
<li><p>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</p>
<p>此ARP请求数据包里包括：源主机的IP地址、MAC地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。</p>
<ul>
<li>如果不相同就忽略此数据包；</li>
<li>如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ul>
</li>
</ul>
<h3 id="5-8-路由设备与相关层"><a href="#5-8-路由设备与相关层" class="headerlink" title="5.8 路由设备与相关层"></a>5.8 路由设备与相关层</h3><ul>
<li>物理层：中继器（Repeater，也叫放大器），集线器。</li>
<li>数据链路层：网桥，交换机。</li>
<li>网络层：路由器。</li>
<li>网络层以上的设备：网关。</li>
</ul>
<h3 id="5-9-常见的路由选择协议，以及它们的区别"><a href="#5-9-常见的路由选择协议，以及它们的区别" class="headerlink" title="5.9 常见的路由选择协议，以及它们的区别"></a>5.9 常见的路由选择协议，以及它们的区别</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p>
<ul>
<li>RIP协议：路由信息协议，底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</li>
<li>OSPF协议：开放最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</li>
</ul>
<h3 id="5-10-VPN-和-NAT"><a href="#5-10-VPN-和-NAT" class="headerlink" title="5.10 VPN 和 NAT"></a>5.10 VPN 和 NAT</h3><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h3 id="5-11-TCP与UDP的区别"><a href="#5-11-TCP与UDP的区别" class="headerlink" title="5.11 TCP与UDP的区别"></a>5.11 TCP与UDP的区别</h3><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</p>
<ul>
<li><p>TCP面向连接；UDP是无连接的。</p>
</li>
<li><p>TCP提供可靠的服务（数据传输），即通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。</p>
</li>
<li><p>TCP面向字节流；UDP面向报文。</p>
</li>
<li><p>TCP数据传输慢；UDP数据传输快。</p>
</li>
<li><p>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信，所以可以广播和多播。</p>
</li>
<li><p>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）。</p>
</li>
<li><p>TCP使用校验和，确认和重传机制来保证可靠传输。</p>
</li>
<li><p>TCP使用累积确认。</p>
</li>
</ul>
<h3 id="5-12-TCP-x2F-UDP应用场景"><a href="#5-12-TCP-x2F-UDP应用场景" class="headerlink" title="5.12 TCP&#x2F;UDP应用场景"></a>5.12 TCP&#x2F;UDP应用场景</h3><p><strong>TCP</strong>：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如：<code>浏览器，用的HTTP；</code> <code>FlashFXP，用的FTP；</code> <code>Outlook，用的POP、SMTP；</code> <code>Putty，用的Telnet、SSH；</code> <code>QQ文件传输</code></p>
<h3 id="5-13-TCP的可靠性如何保证？"><a href="#5-13-TCP的可靠性如何保证？" class="headerlink" title="5.13 TCP的可靠性如何保证？"></a>5.13 TCP的可靠性如何保证？</h3><ul>
<li>确认和超时重传</li>
<li>数据合理分片和排序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>数据校验</li>
</ul>
<h3 id="5-14-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#5-14-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="5.14 在浏览器中输入www.baidu.com后执行的全部过程"></a>5.14 在浏览器中输入<a href="www.baidu.com">www.baidu.com</a>后执行的全部过程</h3><ol>
<li>浏览器获取输入的域名 <a href="www.baidu.com">www.baidu.com</a></li>
<li>浏览器向DNS请求解析 <a href="www.baidu.com">www.baidu.com</a> 的IP地址</li>
<li>DNS解析出百度服务器的IP地址</li>
<li>浏览器与该服务器以三次握手的方式建立TCP连接（默认端口为80）</li>
<li>浏览器发起HTTP请求，请求百度首页</li>
<li>服务器通过HTTP响应，把首页文件发送给浏览器</li>
<li>关闭连接，以TCP四次挥手释放</li>
<li>浏览器将首页文件进行解析，通过浏览器的渲染结果来显示网页</li>
</ol>
<h3 id="5-15-HTTP协议包括哪些请求？"><a href="#5-15-HTTP协议包括哪些请求？" class="headerlink" title="5.15 HTTP协议包括哪些请求？"></a>5.15 HTTP协议包括哪些请求？</h3><ul>
<li>GET：请求读取由URL所标志的信息。</li>
<li>POST：给服务器添加信息（如注释）。</li>
<li>PUT：在给定的URL下存储一个文档。</li>
<li>DELETE：删除给定的URL所标志的资源。</li>
</ul>
<h3 id="5-16-HTTP中，POST与GET的区别"><a href="#5-16-HTTP中，POST与GET的区别" class="headerlink" title="5.16 HTTP中，POST与GET的区别"></a>5.16 HTTP中，POST与GET的区别</h3><ul>
<li>Get是从服务器上获取数据，Post是向服务器传送数据。</li>
<li>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</li>
<li>Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</li>
<li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。<ul>
<li>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</li>
<li>幂等的意味着对同一URL的多个请求应该返回同样的结果。</li>
</ul>
</li>
</ul>
<h3 id="5-17-TCP对应的协议"><a href="#5-17-TCP对应的协议" class="headerlink" title="5.17 TCP对应的协议"></a>5.17 TCP对应的协议</h3><ul>
<li>FTP：定义了<strong>文件传输协议</strong>，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
<li>Telnet：它是一种用于<strong>远程登陆的端口</strong>，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li>
<li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li>
<li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li>
<li>HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<h3 id="5-18-UDP对应的协议"><a href="#5-18-UDP对应的协议" class="headerlink" title="5.18 UDP对应的协议"></a>5.18 UDP对应的协议</h3><ul>
<li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li>
<li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
</ul>
<h3 id="5-19-TCP-三次握手建立连接"><a href="#5-19-TCP-三次握手建立连接" class="headerlink" title="5.19 TCP 三次握手建立连接"></a>5.19 TCP 三次握手建立连接</h3><ol>
<li>第一次握手：客户端发送syn包(syn&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ol>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<h3 id="5-20-TCP-四次挥手释放连接"><a href="#5-20-TCP-四次挥手释放连接" class="headerlink" title="5.20 TCP 四次挥手释放连接"></a>5.20 TCP 四次挥手释放连接</h3><ol>
<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</li>
<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li>
<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li>
</ol>
<img src="/images/image-2022032701.png" alt="TCP三次握手&四次挥手" style="zoom:60%;" />

<h3 id="5-21-TCP-为什么要进行三次握手？"><a href="#5-21-TCP-为什么要进行三次握手？" class="headerlink" title="5.21 TCP 为什么要进行三次握手？"></a>5.21 TCP 为什么要进行三次握手？</h3><p>因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。</p>
<p>双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<h3 id="5-21-TCP-为什么要进行四次挥手？"><a href="#5-21-TCP-为什么要进行四次挥手？" class="headerlink" title="5.21 TCP 为什么要进行四次挥手？"></a>5.21 TCP 为什么要进行四次挥手？</h3><p>因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p>
<h3 id="5-22-为什么-TCP-连接时可以-ACK-和-SYN-一起发送，而释放时则-ACK-和-FIN-分开发送呢？（ACK-和-FIN-分开是指第二次和第三次挥手）"><a href="#5-22-为什么-TCP-连接时可以-ACK-和-SYN-一起发送，而释放时则-ACK-和-FIN-分开发送呢？（ACK-和-FIN-分开是指第二次和第三次挥手）" class="headerlink" title="5.22 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）"></a>5.22 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</h3><p>因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p>
<h2 id="6-计算机组成原理"><a href="#6-计算机组成原理" class="headerlink" title="6 计算机组成原理"></a>6 计算机组成原理</h2><h3 id="6-1-冯诺伊曼结构？"><a href="#6-1-冯诺伊曼结构？" class="headerlink" title="6.1 冯诺伊曼结构？"></a>6.1 冯诺伊曼结构？</h3><p>输入、输出、计算单元、控制单元、存储单元。</p>
<h3 id="6-2-cache的作用是什么？"><a href="#6-2-cache的作用是什么？" class="headerlink" title="6.2 cache的作用是什么？"></a>6.2 cache的作用是什么？</h3><p>cache（高速缓冲存储器）位于CPU和主存之间的，它的容量小，但是速度很快，解决CPU与主存之间速度不匹配的问题。</p>
<h3 id="6-3-指令系统"><a href="#6-3-指令系统" class="headerlink" title="6.3 指令系统"></a>6.3 指令系统</h3><p>CISC复杂指令集，RISC是精简指令集。</p>
<h2 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7 数据库"></a>7 数据库</h2><h3 id="7-1-数据库的发展阶段？"><a href="#7-1-数据库的发展阶段？" class="headerlink" title="7.1 数据库的发展阶段？"></a>7.1 数据库的发展阶段？</h3><p>人工管理阶段-&gt;文件系统阶段-&gt;数据库系统阶段</p>
<h3 id="7-2-什么是数据库系统？"><a href="#7-2-什么是数据库系统？" class="headerlink" title="7.2 什么是数据库系统？"></a>7.2 什么是数据库系统？</h3><p>在计算机系统中引入数据库后的系统。它是由数据库、数据库用户、计算机软硬件、数据库管理员。</p>
<h3 id="7-3-什么是数据库？"><a href="#7-3-什么是数据库？" class="headerlink" title="7.3 什么是数据库？"></a>7.3 什么是数据库？</h3><p>数据库是长期存在计算机内、有组织的、可共享数据集合。</p>
<h3 id="7-4-什么是数据库系统的三级模式？"><a href="#7-4-什么是数据库系统的三级模式？" class="headerlink" title="7.4 什么是数据库系统的三级模式？"></a>7.4 什么是数据库系统的三级模式？</h3><p>模式（逻辑模式或概念模式）、外模式（子模式或用户模式）、内模式（存储模式或物理模式）</p>
<h3 id="7-5-什么是聚集索引或非聚集索引？"><a href="#7-5-什么是聚集索引或非聚集索引？" class="headerlink" title="7.5 什么是聚集索引或非聚集索引？"></a>7.5 什么是聚集索引或非聚集索引？</h3><p>物理存储顺序与逻辑顺序相同</p>
<p>物理存储顺序与索引顺序不一致</p>
<h3 id="7-6-数据库的ACID"><a href="#7-6-数据库的ACID" class="headerlink" title="7.6 数据库的ACID"></a>7.6 数据库的ACID</h3><ul>
<li>原子性Atomicity：一个事务被视为一个最小单元，要么全部提交，要么全部回滚</li>
<li>一致性Consistency：事务总是由一种状态转换为另一种状态，数据库事务只会是执行前的状态或是执行后的状态，不会出现执行中的状态。即如果一个事务执行了十秒，那么第一秒读到的结果和第九秒得到的应该是相同的。</li>
<li>隔离性Isolation：一个事务的执行不会被另一个事务影响，互不干扰。</li>
<li>持久性Durability：事务只要提交了，那么数据库中的数据也永久的发生了变化。</li>
</ul>
<h3 id="7-7-数据库三范式"><a href="#7-7-数据库三范式" class="headerlink" title="7.7 数据库三范式"></a>7.7 数据库三范式</h3><ul>
<li>1NF(Normal Form)：R的所有属性都不能再分解为更基本的数据单位。</li>
<li>2NF：R的所有非主属性都依赖于R的关键属性，所有列都依赖于任意一组候选关键字。</li>
<li>3NF：每一列都与任意候选关键字直接相关而不是间接相关，没有传递依赖。</li>
<li>BCNF：3NF基础上，关系R只有一个单属性，或R的子集都是单属性，则R满足BCNF。</li>
</ul>
<h3 id="7-8-插入100个数据和100万个数据有何区别？"><a href="#7-8-插入100个数据和100万个数据有何区别？" class="headerlink" title="7.8 插入100个数据和100万个数据有何区别？"></a>7.8 插入100个数据和100万个数据有何区别？</h3><p>100数量级小，可以随意插入；100万数量级大，如果表里有索引，则索引更新代价很高，可以采取先删除索引再插入，插入完成后再建索引的策略。</p>
<h3 id="7-9-处理大数据量的策略？"><a href="#7-9-处理大数据量的策略？" class="headerlink" title="7.9 处理大数据量的策略？"></a>7.9 处理大数据量的策略？</h3><p>表分区，备份，入带库。</p>
<h3 id="7-10-一般数据库若出现日志满了，会出现什么情况，是否还能使用？"><a href="#7-10-一般数据库若出现日志满了，会出现什么情况，是否还能使用？" class="headerlink" title="7.10 一般数据库若出现日志满了，会出现什么情况，是否还能使用？"></a>7.10 一般数据库若出现日志满了，会出现什么情况，是否还能使用？</h3><p>只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记录日志。也就是说基本上处于不能使用的状态。</p>
<h2 id="8-软件工程"><a href="#8-软件工程" class="headerlink" title="8 软件工程"></a>8 软件工程</h2><h3 id="8-1-有哪些软件测试分类？"><a href="#8-1-有哪些软件测试分类？" class="headerlink" title="8.1 有哪些软件测试分类？"></a>8.1 有哪些软件测试分类？</h3><ul>
<li>黑盒测试：不考虑软件内部原理，以用户角度测试软件输入输出</li>
<li>白盒测试：知道软件内部工作过程，确定每个分支都能按照预定正常工作</li>
<li>灰盒测试：集合白盒黑盒</li>
<li>冒烟测试：测试软件基本功能，快速</li>
<li>系统测试：验证系统是否满足需求规格的黑盒类测试</li>
<li>性能测试：负载测试和压力测试</li>
<li>安全测试：假扮黑客侵入系统</li>
<li>兼容性测试：不同平台不同环境下的测试</li>
</ul>
<h3 id="8-2-类之间的关系有哪些？"><a href="#8-2-类之间的关系有哪些？" class="headerlink" title="8.2 类之间的关系有哪些？"></a>8.2 类之间的关系有哪些？</h3><ul>
<li>继承：类继承另一个类的功能</li>
<li>实现：类实现接口的功能</li>
<li>依赖：A类的某个方法使用到了B类</li>
<li>关联：强依赖关系，B类作为一个属性出现在了A类</li>
<li>聚合：一种特别的关联，公司与个人的关系</li>
<li>组合：强聚合关系，整体与部分的联系更紧密，如汽车与轮胎</li>
</ul>
<h3 id="8-3-软件工程标准步骤？"><a href="#8-3-软件工程标准步骤？" class="headerlink" title="8.3 软件工程标准步骤？"></a>8.3 软件工程标准步骤？</h3><ol>
<li>问题定义</li>
<li>可行性研究</li>
<li>需求分析</li>
<li>总体设计</li>
<li>详细设计</li>
<li>编码和单元测试</li>
<li>综合测试</li>
<li>软件维护</li>
</ol>
<h3 id="8-4-自顶向下和自底向上测试方法的区别？"><a href="#8-4-自顶向下和自底向上测试方法的区别？" class="headerlink" title="8.4 自顶向下和自底向上测试方法的区别？"></a>8.4 自顶向下和自底向上测试方法的区别？</h3><ul>
<li>自顶向下：从程序入口主控模块开始，按照系统程序结构，沿着控制层次从上而下测试各模块。方便把握整体结构，早期可发现顶层错误。</li>
<li>自底向上：从最底层模块，即叶子结点开始，按照调用从下而上的测试各模块。最后一个模块提交后才能完整系统测试，某些模块可以提前测试。</li>
</ul>
<h3 id="8-5-确定模块的功能和模块的接口是在软件设计的哪个阶段完成的"><a href="#8-5-确定模块的功能和模块的接口是在软件设计的哪个阶段完成的" class="headerlink" title="8.5 确定模块的功能和模块的接口是在软件设计的哪个阶段完成的?"></a>8.5 确定模块的功能和模块的接口是在软件设计的哪个阶段完成的?</h3><p>概要设计阶段</p>
<h3 id="8-6-软件工程的三要素？"><a href="#8-6-软件工程的三要素？" class="headerlink" title="8.6 软件工程的三要素？"></a>8.6 软件工程的三要素？</h3><p>方法、工具、过程。</p>
<h3 id="8-7-软件工程的主要模型？"><a href="#8-7-软件工程的主要模型？" class="headerlink" title="8.7 软件工程的主要模型？"></a>8.7 软件工程的主要模型？</h3><ul>
<li>瀑布模型：前一阶段工作结束才可以进行下一阶段工作。基于文档，易于维护，但加大了工作量。</li>
<li>快速原型：快速建立可以运行的程序，完成的功能是最终软件的一个子集。不带反馈环，满足用户真实需求，但会导致系统设计差，难以维护。</li>
<li>增量模型：每个阶段不交付完整产品，软件由一系列增量构件组成。降低开发风险，易于维护，但不容易控制整体过程。</li>
<li>螺旋模型：结合快速原型和瀑布模型，有利于软件重用，减少风险，风险人员需要一定经验。</li>
<li>喷泉模型：迭代，无缝，节省开发时间。</li>
</ul>
<h3 id="8-8-内聚和耦合"><a href="#8-8-内聚和耦合" class="headerlink" title="8.8 内聚和耦合"></a>8.8 内聚和耦合</h3><ul>
<li>内聚：指一个好的内聚模块内应当尽量只做一件事，描述的是模块内的功能联系。</li>
<li>耦合：各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度。<ul>
<li>内聚类型低→高：功能内聚、信息内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚</li>
<li>耦合类型高→低：内容耦合、公共耦合、外部耦合、控制耦合、标记耦合、数据耦合、非直接耦合</li>
</ul>
</li>
</ul>
<p><em>转载于：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lihello/p/13326858.html%EF%BC%8C">https://www.cnblogs.com/lihello/p/13326858.html，</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/franksimon/p/12610971.html%EF%BC%8C">https://www.cnblogs.com/franksimon/p/12610971.html，</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356319095%EF%BC%8C">https://zhuanlan.zhihu.com/p/356319095，</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinghui_yht/article/details/105443770">https://blog.csdn.net/yinghui_yht/article/details/105443770</a></em></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/14/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E6%9C%BA%E8%AF%95/KMP%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D/" rel="prev" title="「KMP算法 | 串的匹配」">
      <i class="fa fa-chevron-left"></i> 「KMP算法 | 串的匹配」
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/17/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/%E6%9C%BA%E8%AF%95/RPG%E9%97%AE%E9%A2%98/" rel="next" title="「RPG问题」">
      「RPG问题」 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C%E8%AF%AD%E8%A8%80"><span class="nav-text">1 C语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">1.1 标识符的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-i-%E5%92%8C-i-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.2 i++ 和 ++i 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%94%A8%E5%8F%98%E9%87%8Fa%E7%BB%99%E5%87%BA%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.3 用变量a给出下面的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.4 指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">1.5 三种传参方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-include-%E5%B0%96%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.6 #include 尖括号和双引号区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9B%9B%E4%B8%AA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">1.7 程序编译成可执行程序四个的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-text">1.8 如何避免野指针？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C"><span class="nav-text">2 C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-C-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">2.1 C++的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">2.2 C++的异常处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-C-%E7%9A%84%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">2.3 C++的纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%8A%A8%E6%80%81%E5%85%B3%E8%81%94%E5%92%8C%E9%9D%99%E6%80%81%E5%85%B3%E8%81%94%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.4 动态关联和静态关联的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88overried%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.5 重载（overload）和重写（overried）的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-class%E5%92%8Cstruct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.6 class和struct的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">2.7 构造方法（构造函数）的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E8%88%AC%E7%89%B9%E7%82%B9"><span class="nav-text">2.8 内联函数的一般特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">2.9 哪些常见函数不能声明为虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">2.10 友元函数有哪些特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-%E5%AF%B9%E4%BA%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%BA%EF%BC%9F"><span class="nav-text">2.11 对于派生类的构造函数，创建对象时构造函数执行的顺序为？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2.12 模板的使用是为了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-%E5%85%B3%E9%94%AE%E5%AD%97static%E3%80%81const"><span class="nav-text">2.13 关键字static、const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-const%E5%92%8C-define%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.14 const和#define的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 常见的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.3 数组和链表的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">3.4 时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%A2%91%E5%BA%A6%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">（1）语句的频度是指什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%A4%A7T%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-text">（2）大T是什么意思？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A4%A7O%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-text">（3）大O是什么意思？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">3.5 栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-text">（1）括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">（2）用栈实现中缀表达式转后缀表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E6%89%BE%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="nav-text">3.6 找子串问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E6%A0%91"><span class="nav-text">3.7 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-text">3.8 最短路径算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">3.9 哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83"><span class="nav-text">3.10 排序算法及比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">3.11 贪心算法和动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">4 操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">4.1 操作系统的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-text">4.2 操作系统的主要功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">4.3 进程的三个组成部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-text">4.4 并行和并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">4.5 进程和程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%85%B8%E5%9E%8B%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="nav-text">4.6 描述进程的三个基本状态以及它们之间转换的典型原因。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E5%9C%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%97%B6%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">4.7 在创建一个进程时，操作系统需要完成的主要工作是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-text">4.8 死锁产生的原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">4.9 产生死锁的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">4.10 解决死锁的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-%E7%AE%80%E8%BF%B0%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E4%B8%8E%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-text">4.11 简述死锁预防与死锁避免的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">4.12 分页与分段的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-text">4.13 分页与分段内存管理方案如何进行逻辑地址到物理地址的转换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-14-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%9F%E5%AE%83%E5%9C%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%AD%E8%B5%B7%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">4.14 什么是快表？它在地址转换中起什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-15-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">4.15 页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-16-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-x2F-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%EF%BC%89%EF%BC%9F"><span class="nav-text">4.16 调度算法（进程调度&#x2F;作业调度）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-17-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">4.17 磁盘调度算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-18-%E7%A1%AC%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">4.18 硬中断与软中断的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-19-%E4%B8%AD%E6%96%AD%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">4.19 中断和系统调用区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-text">5 计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Internet%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9F%E8%AF%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-text">5.1 Internet采用哪种网络协议？该协议的主要层次结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Internet%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%92%8CIP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-text">5.2 Internet物理地址和IP地址转换采用什么协议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%88%86%E4%B8%BA%E5%93%AA%E4%BF%A9%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">5.3 IP地址的编码分为哪俩部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-OSI%EF%BC%8CTCP-x2F-IP%EF%BC%8C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">5.4 OSI，TCP&#x2F;IP，五层协议的体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">5.5 IP地址的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-IP%E7%BB%84%E6%92%AD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%A5%BD%E5%A4%84"><span class="nav-text">5.6 IP组播有那些好处?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">5.7 ARP协议的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-%E8%B7%AF%E7%94%B1%E8%AE%BE%E5%A4%87%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%B1%82"><span class="nav-text">5.8 路由设备与相关层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.9 常见的路由选择协议，以及它们的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-VPN-%E5%92%8C-NAT"><span class="nav-text">5.10 VPN 和 NAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-11-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.11 TCP与UDP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-12-TCP-x2F-UDP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5.12 TCP&#x2F;UDP应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-13-TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="nav-text">5.13 TCP的可靠性如何保证？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-14-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www-baidu-com%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">5.14 在浏览器中输入www.baidu.com后执行的全部过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-15-HTTP%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="nav-text">5.15 HTTP协议包括哪些请求？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-16-HTTP%E4%B8%AD%EF%BC%8CPOST%E4%B8%8EGET%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.16 HTTP中，POST与GET的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-17-TCP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">5.17 TCP对应的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-18-UDP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">5.18 UDP对应的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-19-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-text">5.19 TCP 三次握手建立连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-20-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="nav-text">5.20 TCP 四次挥手释放连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-21-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-text">5.21 TCP 为什么要进行三次握手？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-21-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-text">5.21 TCP 为什么要进行四次挥手？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-22-%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%8F%AF%E4%BB%A5-ACK-%E5%92%8C-SYN-%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%EF%BC%8C%E8%80%8C%E9%87%8A%E6%94%BE%E6%97%B6%E5%88%99-ACK-%E5%92%8C-FIN-%E5%88%86%E5%BC%80%E5%8F%91%E9%80%81%E5%91%A2%EF%BC%9F%EF%BC%88ACK-%E5%92%8C-FIN-%E5%88%86%E5%BC%80%E6%98%AF%E6%8C%87%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%92%8C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89"><span class="nav-text">5.22 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="nav-text">6 计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-text">6.1 冯诺伊曼结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-cache%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">6.2 cache的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-text">6.3 指令系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">7 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="nav-text">7.1 数据库的发展阶段？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="nav-text">7.2 什么是数据库系统？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-text">7.3 什么是数据库？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">7.4 什么是数据库系统的三级模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%88%96%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">7.5 什么是聚集索引或非聚集索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84ACID"><span class="nav-text">7.6 数据库的ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-text">7.7 数据库三范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-%E6%8F%92%E5%85%A5100%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%92%8C100%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">7.8 插入100个数据和100万个数据有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-%E5%A4%84%E7%90%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-text">7.9 处理大数据量的策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10-%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8B%A5%E5%87%BA%E7%8E%B0%E6%97%A5%E5%BF%97%E6%BB%A1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%8C%E6%98%AF%E5%90%A6%E8%BF%98%E8%83%BD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">7.10 一般数据库若出现日志满了，会出现什么情况，是否还能使用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="nav-text">8 软件工程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="nav-text">8.1 有哪些软件测试分类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">8.2 类之间的关系有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%87%E5%87%86%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="nav-text">8.3 软件工程标准步骤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">8.4 自顶向下和自底向上测试方法的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E7%A1%AE%E5%AE%9A%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E7%9A%84"><span class="nav-text">8.5 确定模块的功能和模块的接口是在软件设计的哪个阶段完成的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="nav-text">8.6 软件工程的三要素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-text">8.7 软件工程的主要模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-%E5%86%85%E8%81%9A%E5%92%8C%E8%80%A6%E5%90%88"><span class="nav-text">8.8 内聚和耦合</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ni256o"
      src="/images/avatar01.JPG">
  <p class="site-author-name" itemprop="name">Ni256o</p>
  <div class="site-description" itemprop="description">The sole certainty is that tomorrow will surprise us all.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/c2560214@163.com" title="E-Mail → c2560214@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022.03.13 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ni256o</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
